# 二叉树的按层打印与ZigZag打印
## 题目
给定一颗二叉树的头结点head,分别实现按成打印和ZigZag打印二叉树的函数。
## 按层打印的实现
### C++实现:
```cpp
struct Node{
	int value;
	Node* left;
	Node* right;
	Node(int x) : value(x), left(NULL), right(NULL) {}
};

void printByLevel(Node* head) {
	if (NULL == head)
		return;
	queue<Node*> mq;
	Node* last = head; // 每层最右边的结点
	int level = 1;

	mq.push(head); // 根结点先入队
	cout << "Level " << level << ": ";
	while (!mq.empty()) {
		Node* cur = mq.front();
		cout << cur->value << " ";
		// 把当前结点的孩子结点入队
		if (NULL != cur->left)
			mq.push(cur->left);
		if (NULL != cur->right)
			mq.push(cur->right);

		if (cur == last) {
			last = mq.back(); // 下一层的最后一个结点
			++level;
			cout << endl;
			if (cur != last)
				cout << "Level " << level << ": ";
		}

		// 当前结点出队
		mq.pop();
	}
}
```
### Java实现
## 按ZigZag打印的实现
### C++实现:
#### 方法1
```cpp
struct Node {
	int value;
	Node* left;
	Node* right;
	Node(int x) : value(x), left(NULL), right(NULL) {}
};

void printByZigZag(Node* head) {
	if (NULL == head)
		return;
	queue<Node*> mq;	// 按层入队
	stack<Node*> ms;	// 保存下一层的全部结点
	int level = 1;
	mq.push(head);

	while(!mq.empty()) {
		Node* cur = NULL;
		// 奇数层，从左往右打印
		// 偶数层，从右往左打印
		if (1 == level % 2) {
			cout << "Level " << level << "from left to right: ";
			// 把下一层从左往右入栈
			while (!mq.empty) {
				cur = mq.front();
				if (NULL != cur->left)
					ms.push(cur->left);
				if (NULL != cur->right)
					ms.push(cur->right);

				// 打印结点值
				cout << cur->value << " ";
				mq.pop();
			}
		} else {
			cout << "Level " << level << "from right to left: ";
			// 下一层结点从右往左入栈
			while (!mq.empty) {
				cur = mq.front();
				if (NULL != cur->right)
					ms.push(cur->right);
				if (NULL != cur->left)
					ms.push(cur->left);
				cout << cur->value << " ";
				mq.pop();
			}
		}

		cout << endl;
		
		// 把下一层结点入队
		while (!ms.empty()) {
			mq.push(ms.top());
			ms.pop();
		}
		
		++level;
	}
}
```
#### 方法2
```cpp
struct Node {
	int value;
	Node* left;
	Node* right;
	Node(int x) : value(x), left(NULL), right(NULL) {}
};

void printByZigZag(Node* head) {
	if (NULL == head) 
		return;
	deque<Node*> dq;
	Node* last = head;
	int level = 1;
	dq.push_front(head);
	cout << "Level " << level << " from left to right: ";

	while (!dq.empty()) {
		// 从左往右遍历
		// 1)从队头出队
		// 2)从队尾入队:先左孩子，后右孩子
		if (1 == level % 2) {
			head = dq.front();
			dq.pop_front();
			cout << head->value << " ";
			if (NULL != head->left) 
				dq.push_back(head->left);
			if (NULL != head->right)
				dq.push_back(head->right);

			// 遍历到当前层最右结点
			if (head == last && !dq.empty()) {
				// 下一层最后遍历的结点在最左边
				// 也就是队列的队头
				last = dq.front();
				++level;
				cout << endl;
				cout << "Level " << level << " from right to left: ";
			}
		} else {
			// 从右往左遍历
			// 1)从队尾出队
			// 2)从队头入队:先右孩子,后左孩子
			head = dq.back();
			dq.pop_back();
			cout << head->value << " ";
			if (NULL != head->right)
				dq.push_front(head->right);
			if (NULL != head->left)
				dq.push_front(head->left);

			if (head == last && !dq.empty()) {
				last = dq.back();
				++level;
				cout << endl;
				cout << "Level " << level << " from left to right: ";
			}
		}
		cout << endl;
	}
```
### Java实现
